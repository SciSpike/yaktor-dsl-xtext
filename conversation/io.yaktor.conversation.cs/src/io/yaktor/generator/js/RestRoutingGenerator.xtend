package io.yaktor.generator.js

import io.yaktor.access.RestAccess
import io.yaktor.access.RestService
import io.yaktor.conversation.Conversation
import io.yaktor.generator.ConversationOutputConfigurationProvider
import io.yaktor.types.Projection
import org.eclipse.xtext.generator.IFileSystemAccess

import static extension io.yaktor.generator.util.CommentExtractorExtensions.*


import static extension io.yaktor.generator.js.JsTypesExtensions.*
import java.util.HashMap
import java.util.TreeSet
import org.eclipse.xtext.generator.AbstractFileSystemAccess2

class RestRoutingGenerator {
  def static endpointsPath(Conversation c, RestService rs) {
    c.endpointsPath(rs.server)
  }

  def static endpointsPath(Conversation c, String server) {
    '''rest/«server?:"DEFAULT"»'''
  }
  def static routePath(Conversation c, String server) {
    '''routes/«server?:"DEFAULT"»'''
  }
  def static actionsPath(Conversation c, String server) {
    '''actions/«server?:"DEFAULT"»'''
  }
  def static configPath(Conversation c, String server) {
    '''config/servers/«server?:"DEFAULT"»'''
  }
  def generate(IFileSystemAccess fsa, Conversation c) {
    var routeMap = new HashMap<String,StringBuilder>
    var servers = new TreeSet<String>
    var counter = 0
    for (rs : c.restServices.sortWith[rs1, rs2|rs1.url.compareTo(rs2.url)]) {
      if (rs.server != null){servers.add(rs.server)}
      var thisEndpointsPath = c.endpointsPath(rs)
      var route =  '''
        /**
         * Methods for «rs.url»
         */
        var rs$«rs.refType.name»$«counter» = require(require('path').resolve('«ConversationOutputConfigurationProvider.GEN_ONCE_ROOT_CONFIG.outputDirectory»', '«thisEndpointsPath»«rs.url»', '«rs.refType.name».js'))
        «c.genMethodRoutes(rs, counter)»
      '''
      routeMap.put(rs.server?:"DEFAULT",(routeMap.get(rs.server?:"DEFAULT")?:new StringBuilder).append(route))
      counter = counter + 1
      fsa.generateFile(thisEndpointsPath + "/" + rs.url + "/" + rs.refType.name + ".def.js",
        ConversationOutputConfigurationProvider.GEN_ROOT, c.genRestServices(rs))
      fsa.generateFile(thisEndpointsPath + "/" + rs.url + "/" + rs.refType.name + ".js",
        ConversationOutputConfigurationProvider.GEN_ONCE_ROOT, '''
          (function () {
            'use strict'
            module.exports = require('./«rs.refType.name».def.js')
          })()
        ''')

      fsa.generateFile('''«c.actionsPath(rs.server)»/«rs.url.replaceAll("/","%")».js''', ConversationOutputConfigurationProvider.GEN_ROOT, '''
          «FOR ag : rs.accessGroups»
            «FOR m : ag.accessMethods»
              «var regex = rs.actionPath(m)»
              module.exports['«regex»'] = module.exports['«regex»'] || {}
              module.exports['«regex»']['«m.method.toLowerCase»'] = '«ag.accessRequirement»'
            «ENDFOR»
          «ENDFOR»
      ''')
    }
    var serverCounter = 0
    var defaultServerName = "DEFAULT"
    servers.add(defaultServerName)
    for(server:servers.sort){
	    fsa.generateFile('''«c.configPath(server)»/index.js''', ConversationOutputConfigurationProvider.GEN_ONCE_ROOT, '''
        var path = require('path')
        var fs = require('fs')
        var async = require('async')
        var regex = /\.js$/
        module.exports = {
          settings: {
            serverName: '«server»',
            host: {
              port: «IF server  == defaultServerName»80«ELSE»«3000+serverCounter»«ENDIF»,
              protocol: 'http',
              prefix: '',
              hostname: null
            },
            path: {
              routesPath: path.resolve('«c.routePath(server)»'),
              actionsPath: path.resolve('«c.actionsPath(server)»')
            }
          },
          init: function (ctx, done) {
            // NOTE: Sorting is required, due to the fact that no order is guaranteed
            //       by the system for a directory listing.  Sorting allows initializers
            //       to be prefixed with a number, and loaded in a pre-determined order.
            var files = fs.readdirSync(__dirname).sort()
            async.forEachSeries(files, function (file, next) {
              var pathname = path.join(__dirname, file)
              if (fs.lstatSync(pathname).isDirectory() || file === 'index.js' || !regex.test(file)) return next()
        
              try {
                var initializer = require(pathname)
                if (typeof initializer === 'function') initializer(ctx, next)
                else next()
              } catch (e) {
                next(e)
              }
            }, done)
          }
        }
      ''')
      serverCounter = serverCounter + 100
      fsa.generateFile('''«c.routePath(server)»/«c.name».js''', ConversationOutputConfigurationProvider.GEN_ROOT,'''
        /*
         * This file was generated by the Yaktor code generators
         */
        module.exports = function (ctx) {
          «routeMap.get(server)?.toString»
        }
      ''')
      fsa.generateFile('''«c.configPath(server)»/00_app.js''', ConversationOutputConfigurationProvider.GEN_ONCE_ROOT,'''
        /*
         * This file was generated by the Yaktor code generators
         *
         */
        var express = require('express')
        module.exports = function (ctx, done) {
          var protocol = ctx.host.protocol
          var serverFactory = require(protocol)
          var app = ctx.app = express()
          ctx.server = (protocol === 'http')
            ? serverFactory.createServer(app)
            : serverFactory.createServer(ctx.host.options, app)
          done()
        }
      ''')
      for(fileName : #['10_routes.js','01_hostname.js','20_listen.js','05_middleware.js']){
      	try{
          fsa.generateFile('''«c.configPath(server)»/«fileName»''', ConversationOutputConfigurationProvider.GEN_ONCE_ROOT, (fsa as AbstractFileSystemAccess2).readTextFile('''«c.configPath(defaultServerName)»/«fileName»''',ConversationOutputConfigurationProvider.GEN_ONCE_ROOT))
       	} catch(Exception e){}
      }
      fsa.generateFile('''«c.actionsPath(server)»/index.js''', ConversationOutputConfigurationProvider.GEN_ROOT, '''
        var fs = require('fs')
        var path = require('path')
        fs.readdirSync(__dirname).forEach(function (file) {
          var filePath = path.join(__dirname, file)
          if (__filename !== filePath) {
            var mod = require(filePath)
            for (var model in mod) {
              module.exports[model] = mod[model]
            }
          }
        })
      ''')
    }
  }


  def static repeat(String string, int times) {
    var count = 0
    var result = new StringBuilder
    while ((count = count + 1) <= times) {
      result.append(string)
    }
    return result.toString()
  }

  def genRestServices(Conversation c, RestService rs) {
    '''
        «IF rs.refType.entity != null»
          var «rs.refType.entity.name» = require('mongoose').model('«rs.refType.entity.name»')
          var converter = require('yaktor/services/conversionService')
          var async = require('async')
        «ENDIF»
        var Response = require('yaktor/services/Response')
        «rs.comments»
        «FOR method : rs.methods.sort»
          «method.restService(rs)»
        «ENDFOR»
      '''
  }

  def restService(RestAccess method, RestService rs) {
    '''
      /*
       * «method.crud»
       * «method.method.toUpperCase» «rs.path(method)»
       * for «rs.refType.name»
       * Optionally module.exports.«method.crud»Middleware = [function...]||function
       */
    ''' + switch method {
      case method == RestAccess.POST: '''
        module.exports.«method.crud» = function (body, req, res) {
          «IF rs.refType.entity != null»
            async.waterfall([
              async.apply(converter.from, '«rs.refType.fullName»', body),
              async.apply(«rs.refType.repositoryServiceName».create.bind(«rs.refType.repositoryServiceName»)),
              async.apply(converter.to, '«rs.refType.fullName»') //
            ], Response.create(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»'))
          «ELSE»
            // No Domain
            Response.create(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»')(null, body)
          «ENDIF»
        }
      '''
      case method == RestAccess.GET: '''
        module.exports.«method.crud» = function (id, req, res) {
          «IF rs.refType.entity != null»
            async.waterfall([
              async.apply(«rs.refType.repositoryServiceName».findOne.bind(«rs.refType.repositoryServiceName»), {_id: id}),
              async.apply(converter.to, '«rs.refType.fullName»') //
            ], Response.read(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»'))
          «ELSE»
            // No Domain
            Response.read(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»')(null, req.query)
          «ENDIF»
        }
      '''
      case method == RestAccess.PUT: '''
        module.exports.«method.crud» = function (id, body, req, res) {
          «IF rs.refType.entity != null»
            async.waterfall([
              async.apply(converter.from, '«rs.refType.fullName»', body),
              function (domain, cb) {
                «rs.refType.repositoryServiceName».findOneAndUpdate({ _id: id }, domain, { new: true }, cb)
              },
              async.apply(converter.to, '«rs.refType.fullName»') //
            ], Response.update(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»'))
          «ELSE»
            // No Domain
            Response.update(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»')(null, body)
          «ENDIF»
        }
      '''
      case method == RestAccess.DELETE: '''
        module.exports.«method.crud» = function (id, req, res) {
          «IF rs.refType.entity != null»
            «rs.refType.repositoryServiceName».findOneAndRemove({ _id: id }, Response.delete(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»'))
          «ELSE»
            // No Domain
            Response.delete(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»')(null)
          «ENDIF»
        }
      '''
      case method == RestAccess.FIND: '''
        module.exports.«method.crud» = function (query, req, res) {
          «IF rs.refType.entity != null»
            async.waterfall([
              async.apply(converter.toQuery, '«rs.refType.fullName»', query),
              function (pQ, cb) {
                var page = parseInt(req.params.page) || 1
                var pageSize = parseInt(req.params.pageSize) || 10
                «rs.refType.repositoryServiceName».find(pQ).paginate(page, pageSize, cb)
              },
              function (domains, total, cb) {
                converter.to('«rs.refType.fullName»', domains, function (err, dtos) {
                  cb(err, dtos, total)
                })
              } //
            ], Response.find(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»'))
          «ELSE»
            // No Domain
            Response.find(req, res, '«FOR type : rs.supportedDocumentTypes.sort SEPARATOR ','»«type.literal»«ENDFOR»')(null, [])
          «ENDIF»
        }
      '''
    }
  }

  def getRepositoryServiceName(Projection p) {
    if (p.entity != null) {
      p.entity.name
    } else {
      p.name
    }
  }


  def genMethodRoutes(Conversation c, RestService rs, int counter) {
    '''
    «FOR method : rs.methods.sort SEPARATOR ''»
      «method.methodRoute(rs, counter)»
    «ENDFOR»
    '''
  }

  def methodRoute(RestAccess method, RestService rs, int counter) {
    '''
    /*
     * «method.crud» a «rs.refType.name»
     */
    ctx.app.«method.method.toLowerCase»('«rs.path(method)»', rs$«rs.refType.name»$«counter».«method.crud»Middleware || [], function (req, res, next) { rs$«rs.
      refType.name»$«counter».«method.crud»''' + switch method {
      case method == RestAccess.POST: '(req.body, req, res, next) })'
      case method == RestAccess.GET: "(req.params.id, req, res, next) })"
      case method == RestAccess.PUT: "(req.params.id, req.body, req, res, next) })"
      case method == RestAccess.DELETE: "(req.params.id, req, res, next) })"
      case method == RestAccess.FIND: '(req.query, req, res, next) })'
    }
  }

  def path(RestService rs, RestAccess method) {
    switch method {
      case method == RestAccess.POST:
        rs.url
      case method == RestAccess.GET: '''«rs.url»/:id'''
      case method == RestAccess.PUT: '''«rs.url»/:id'''
      case method == RestAccess.DELETE: '''«rs.url»/:id'''
      case method == RestAccess.FIND:
        rs.url
    }
  }
  def actionPath(RestService rs, RestAccess method) {
    var regexUrl = "^"+rs.url
    switch method {
      case method == RestAccess.POST:
        regexUrl+"$"
      case method == RestAccess.GET: '''«regexUrl»/[^/]+$'''
      case method == RestAccess.PUT: '''«regexUrl»/[^/]+$'''
      case method == RestAccess.DELETE: '''«regexUrl»/[^/]+$'''
      case method == RestAccess.FIND:
        regexUrl+"$"
    }
  }

  def crud(RestAccess method) {
    switch method {
      case method == RestAccess.POST: 'create'
      case method == RestAccess.GET: 'read'
      case method == RestAccess.PUT: 'update'
      case method == RestAccess.DELETE: 'delete'
      case method == RestAccess.FIND: 'find'
    }
  }

  def method(RestAccess method) {
    switch method {
      case method == RestAccess.POST: 'post'
      case method == RestAccess.GET: 'get'
      case method == RestAccess.PUT: 'put'
      case method == RestAccess.DELETE: 'delete'
      case method == RestAccess.FIND: 'get'
    }
  }

}
