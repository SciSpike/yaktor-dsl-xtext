grammar io.yaktor.Conversation with io.yaktor.Domain

import "http://www.eclipse.org/Xtext/io.yaktor.conversation"
import "http://www.eclipse.org/Xtext/io.yaktor.types"
import "http://www.eclipse.org/Xtext/io.yaktor.access" as access
import "http://www.eclipse.org/Xtext/io.yaktor.domain" as domain

Conversation returns Conversation:
  'conversation' name=ID '{'
  ('imports' '{'
  (importedAgents+=AgentImport |
  importedTypes+=TypeImport)*
  '}')?
  (agents+=Agent |
  views+=View |
  restServices+=RestService |
  definedTypes+=TopLevelProjection |
  services+=Service)*
  '}';

enum StateMachineType:
  finite | infinite | stateless;

AgentImport:
  'agent' agent=[Agent|QualifiedName] ('as' alias=ID)?;

TypeImport:
  ('type' | 'message') type=[Projection|QualifiedName] ('as' alias=ID)?;

QualifiedName:
  ID ('.' ID)+;
  

PossiblyQualifiedName:
  ID ('.' ID)*;

Agent returns Agent:
  (stateMachineType=StateMachineType)? (accessRequirement=AccessRequirement)? 'agent' name=ID (('concerning' | 'concerns')
  projection=[Projection|PossiblyQualifiedName]) '{'
  events+=Event*
  stateMachine=StateMachine
  '}';

StateMachine returns StateMachine:
  {StateMachine}
  'initially' ( (  'becomes' initialState=[State])
  | ( initialTransition=Transition))
  '{'
  states+=StateLike*
  '}';

Event:
  ('privately' 'receives' {PrivatePubSub} | 'sends'
  {PubliclySubscribable} | 'receives' {PubliclyPublishable} | 'pubsub' {PublicPubSub})
  name=ID
  (':' refType=[Projection|PossiblyQualifiedName])?;

StateLike returns State:
  State | Decision | Join;
Junction returns Junction:
  message=[SubscribableByOthers|QualifiedName]
  ('[' fieldMapping=[ProjectionField|PossiblyQualifiedName] ']')?
;


Join returns Join:
  'while' ('in')?  (requiresExecution?="custom")? name=ID 'waits' 'for' joins+=Junction (','|'and' joins+=Junction)*
  '{'
  (transitions+=Transition)*
  '}';

Decision returns Decision:
  'decision' name=ID
  '{'
  (transitions+=InternalTransition)*
  '}';

State returns State:
  ('while' ('in')?)? (requiresExecution?="custom")? name=ID
  '{'
  (transitions+=Transition)*
  '}';

Transition returns Transition:
  {Transition}
   ('receives')? (requiresExecution?='custom')?
    ((causedBy=[SubscribableByMe|ID] | 
     exCausedBy=[SubscribableByOthers|QualifiedName])
       ('[' fieldMapping=[ProjectionField|PossiblyQualifiedName] ']')? )
  
  ('->'|'becomes') toState=[State|ID]
  (('>'|'sends') (triggers=[PublishableByMe|ID] |
  exTriggers=[PublishableByOthers|QualifiedName]))?;

InternalTransition returns Transition:
  {Transition}
   (requiresExecution?='custom')? causedBy=[PrivatePubSub|ID]
  ('->'|'becomes') toState=[State|ID]
  (('>'|'sends') (triggers=[PublishableByMe|ID] |
  exTriggers=[PublishableByOthers|QualifiedName]))?;

ProjectionField:
  MappedField | NewField | ProjectionContainmentField | TypeContainmentField;

ProjectionContainmentField:
  {ProjectionContainmentField}
  'val' projection=[Projection|PossiblyQualifiedName]
  alias=ID
  (cardinality=Cardinality)?;

TypeContainmentField:
  {TypeContainmentField}
  => 'val' newField=TypeField
  projection=NestedProjection;

NewField:
  {NewField}
  (newField=SimpleField | newField = AnyField);

MappedField:
  {MappedField}
  (oldField=[domain::Field|ID] ('as' alias=ID)? (projection=NestedProjection)?);

TopLevelProjection returns Projection:
  ('type' | 'message') name=ID ('from' entity=[domain::Entity|PossiblyQualifiedName])?
  '{'
  (fields+=ProjectionField)*
  '}';

NestedProjection returns Projection:
  {Projection}
  '{'
  (fields+=ProjectionField)*
  '}';

enum AccessRequirement returns access::AccessRequirement:
  ANONYMOUS='anonymous' | AUTHENTICATED='authenticated' | DEFAULT='default' | AUTHORIZED='authorized';

RestService returns access::RestService:
  'resource' url=Path
  'for' refType=[Projection|PossiblyQualifiedName]
  'offers' accessGroups+=AccessGroup+
  ('interchanges' '(' supportedDocumentTypes+=RestDocumentType+ ')')?
  ('at' (server=ID | 'default') )?;

AccessGroup returns access::AccessGroup:
  (accessRequirement=AccessRequirement)?  '(' accessMethods+= RestAccess+ ')'
  
;

View returns access::View:
  'view' url=Path
  'over' backedBy=[access::RestService|Path];

Service returns access::Service:
  'service' name=ID '{'
  methods+=ServiceMethod+
  '}';

ServiceMethod returns access::ServiceMethod:
  name=ID '('
  (inputParams+=[Projection|PossiblyQualifiedName] (',' inputParams+=[Projection|PossiblyQualifiedName])*)?
  ')'
  (':' (outputParams+=[Projection|PossiblyQualifiedName] (',' outputParams+=[Projection|PossiblyQualifiedName])*))?;

enum RestDocumentType returns access::RestDocumentType:
  json="json" | xml="xml" | yaml="yaml" | form="form" | upload="multi-part" | xhtml="text";

enum RestAccess returns access::RestAccess:
  Post='create' | Post='post' | Get='read' | Put='update' | Delete='delete' | Find='find';

Path:
  ('/' PossiblyQualifiedName)+;


