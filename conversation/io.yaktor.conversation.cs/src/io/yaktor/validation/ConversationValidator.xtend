/*
 * generated by Xtext
 */
package io.yaktor.validation

import io.yaktor.conversation.ConversationPackage
import io.yaktor.conversation.StateMachine
import io.yaktor.conversation.StateMachineType
import io.yaktor.conversation.Transition
import io.yaktor.domain.TypeField
import io.yaktor.types.MappedField
import io.yaktor.types.TypesPackage
import java.util.HashSet
import java.util.Set
import org.eclipse.xtext.validation.Check
import io.yaktor.conversation.PubliclySubscribable

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ConversationValidator extends AbstractConversationValidator {

  @Check
  def checkProjectionOnTypeFields(MappedField field) {
    var uField = field.oldField ?: field.newField
    if (uField != null && uField instanceof TypeField && field.projection == null) {
      error("Mappings of types must have a projection.", field,
        TypesPackage.eINSTANCE.mappedField_Projection, IssueCodes.MISSING_PROJECTION)
    }
  }

  @Check
  def checkValidEvent(Transition t) {
    if (t.causedBy == null && t.exCausedBy == null) {
      error("Cause is required.", t,
        ConversationPackage.eINSTANCE.transition_CausedBy, IssueCodes.MISSING_CAUSE)
    }
    // TODO: disallow t.causedBy.name == t.triggers.name
  }
  
  @Check
  def checkValidEventTypeContinuity(Transition t) {
    var cause = t?.causedBy
    var trigger =t?.triggers ?: t?.exTriggers
    if (!t.requiresExecution && cause != null && cause?.refType !=  trigger.refType) {
      warning("Input doesn't match output.", t,
        ConversationPackage.eINSTANCE.transition_CausedBy, IssueCodes.TRANSITION_TYPE_IMPEDENCE)
    }
  }
  
  @Check
  def checkValidEventMapping(Transition t) {
    if (t.mapping == null && t.exCausedBy?.refType != t?.toState?.parent?.parent?.projection) {
      warning("Cause implies mapping.", t,
        ConversationPackage.eINSTANCE.transition_CausedBy, IssueCodes.TRANSITION_TYPE_IMPEDENCE)
    }
  }
  
  @Check
  def checkValidEventType(Transition t) {
    if (t.mapping == null && t?.exCausedBy?.refType == null && t?.toState?.parent?.parent?.projection != (t?.exCausedBy as PubliclySubscribable)?.parent?.projection) {
      warning("Agent mapping impossible.", t,
        ConversationPackage.eINSTANCE.transition_CausedBy, IssueCodes.TRANSITION_TYPE_IMPEDENCE)
    }
  }

  @Check
  def checkValidStateModel(StateMachine sm) {

    //    var agent = sm.parent
    //    if (sm.initialTransition == null && agent.stateMachineType == StateMachineType.FINITE) {
    //      error("A finite agent begins on an event.", sm,
    //        ConversationPackage.eINSTANCE.stateMachine_InitialState, IssueCodes.INVALID_STATE_MODEL)
    //    }
    return
  }

  @Check
  def checkValidState(StateMachine sm) {
    var agent = sm.parent
    var end = if (sm.initialState != null) {
        sm.initialState.terminalState(null)
      } else {
        sm.initialTransition?.toState?.terminalState(null)
      }
    if (agent.stateMachineType == StateMachineType.FINITE && end == null) {
      error("finite agent, " + agent.name + ", must contain a least one reachable terminal state.", agent,
        ConversationPackage.eINSTANCE.agent_StateMachine, IssueCodes.EVENT_LOOP)
    } else if (agent.stateMachineType != StateMachineType.FINITE && end != null) {
      error("infinite agent, " + agent.name + ", must NOT contain ANY reachable terminal state(s).", agent,
        ConversationPackage.eINSTANCE.agent_StateMachineType, IssueCodes.EVENT_LOOP)
    }
  }

  def io.yaktor.conversation.State terminalState(io.yaktor.conversation.State start,
    Set<io.yaktor.conversation.State> visited) {
    var mv = visited ?: new HashSet<io.yaktor.conversation.State>;
    if (start == null) {
      return start
    } else if (start.transitions.size < 1) {
      return start
    } else {
      mv.add(start)
      var io.yaktor.conversation.State end = null
      for (trans : start.transitions) {
        if (!mv.contains(trans.toState)) {
          end = end ?: trans.toState.terminalState(mv)
          if (end != null) {
            return end;
          }
        }
      }
      return end;
    }
  }
}
